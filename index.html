<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- SEO Meta Tags -->
    <title>Sort-of-Art | Glitch Art & Pixel Sorting Tool</title>
    <meta name="description" content="A browser-based creative tool that uses sorting algorithms and cinematic effects to transform your images into unique glitch art. Experiment with pixel sorting, retro filters, and more.">
    <meta name="keywords" content="glitch art, pixel sorting, digital art, image effects, photo editor, radix sort, creative coding, generative art, movie effects">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://mmmmaharshi.github.io/Sort-of-Art/">
    <meta property="og:title" content="Sort-of-Art | Glitch Art & Pixel Sorting Tool">
    <meta property="og:description" content="Transform your images into unique glitch art with pixel sorting, cinematic effects, and real-time customizable filters.">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://mmmmaharshi.github.io/Sort-of-Art/">
    <meta property="twitter:title" content="Sort-of-Art | Glitch Art & Pixel Sorting Tool">
    <meta property="twitter:description" content="Transform your images into unique glitch art with pixel sorting, cinematic effects, and real-time customizable filters.">

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        canvas { max-width: 100%; height: auto; border-radius: 0.5rem; }
        .effect-btn.active { background-color: #4c51bf; box-shadow: 0 0 0 2px #a3bffa; }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center min-h-screen p-4">
    <main class="w-full max-w-6xl bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8 space-y-6">
        <header class="text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-indigo-600">Sort-of-Art</h1>
            <p class="text-gray-400 mt-2">An unconventional use of sorting algorithms for creating glitch art.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <aside class="lg:col-span-1 bg-gray-700/50 p-6 rounded-lg space-y-4 flex flex-col">
                <section aria-labelledby="upload-heading">
                    <h2 id="upload-heading" class="block text-lg font-medium text-gray-300 mb-2">1. Upload Image</h2>
                    <input type="file" id="imageUpload" accept="image/*" class="block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-500 file:text-white hover:file:bg-indigo-600 transition-colors cursor-pointer"/>
                </section>
                
                <section id="main-effects-panel" aria-labelledby="effects-heading">
                    <h2 id="effects-heading" class="block text-lg font-medium text-gray-300 mb-2">2. Select Effect</h2>
                    <div id="effects-grid" class="grid grid-cols-2 md:grid-cols-3 gap-2">
                        <!-- Buttons will be populated by JS -->
                    </div>
                </section>

                <section id="effect-options-container" class="border-t border-gray-600 pt-4 space-y-3" aria-live="polite">
                    <!-- Sliders will be populated by JS -->
                </section>

                <div class="flex-grow"></div>

                <div class="flex flex-col sm:flex-row gap-4 pt-4">
                    <button id="resetBtn" class="w-full bg-gray-500 text-white font-bold py-3 px-4 rounded-lg" disabled>Reset</button>
                    <a id="downloadBtn" class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg text-center hidden" href="#" download="sorted-image.png">Download</a>
                </div>
                
                <div id="loader" class="hidden mx-auto text-center">
                    <div class="loader inline-block"></div>
                    <p id="loader-text" class="text-center mt-2 text-gray-400">Processing...</p>
                    <button id="cancelBtn" class="mt-4 bg-red-600 text-white font-bold py-2 px-4 rounded-lg">Cancel</button>
                </div>
            </aside>

            <div class="lg:col-span-2 relative bg-gray-900 rounded-lg flex items-center justify-center p-4 min-h-[400px]">
                <canvas id="canvas" aria-label="Image manipulation canvas"></canvas>
                <p id="canvas-placeholder" class="text-gray-500">Your image will appear here</p>
            </div>
        </div>
    </main>

    <script>
        // --- Element Selection ---
        const imageUpload = document.getElementById('imageUpload');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const resetBtn = document.getElementById('resetBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const loader = document.getElementById('loader');
        const loaderText = document.getElementById('loader-text');
        const cancelBtn = document.getElementById('cancelBtn');
        const canvasPlaceholder = document.getElementById('canvas-placeholder');
        const effectsGrid = document.getElementById('effects-grid');
        const optionsContainer = document.getElementById('effect-options-container');

        let originalImageData = null;
        let originalImage = new Image();
        let allButtons = [];
        let isCancelled = false;
        let activeEffect = null;
        let debounceTimer;

        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // --- WEB WORKER SETUP ---
        const workerScript = `
            function getPixelArray(data) { const p = []; for (let i = 0; i < data.length; i += 4) p.push([data[i], data[i+1], data[i+2], data[i+3]]); return p; }
            function countingSortStable(pixels, c) { const max=255; const counts=new Array(max+1).fill(0); const out=new Array(pixels.length); for (let i=0; i<pixels.length; i++) counts[pixels[i][c]]++; for (let i=1; i<=max; i++) counts[i]+=counts[i-1]; for (let i=pixels.length-1; i>=0; i--) { const p=pixels[i], v=p[c], pos=counts[v]-1; out[pos]=p; counts[v]--; } return out; }
            function radixSortRGB(pixels) { let s=countingSortStable(pixels,2); s=countingSortStable(s,1); return countingSortStable(s,0); }
            function countingSortByValue(pixels, getValue) { const buckets={}; for (const p of pixels) { const v=getValue(p); if(!buckets[v]) buckets[v]=[]; buckets[v].push(p); } const sP=[]; const sK=Object.keys(buckets).map(Number).sort((a,b)=>a-b); for (const k of sK) { const bucket=buckets[k]; for(let i=0;i<bucket.length;i++) sP.push(bucket[i]); } return sP; }
            self.onmessage = (e) => {
                const { type, imageData, sortType } = e.data;
                const pixels = getPixelArray(imageData.data);
                let sortedPixels;
                if (type === 'sortFull') {
                    if (sortType === 'rgb') sortedPixels = radixSortRGB(pixels);
                    else if (sortType === 'brightness') sortedPixels = countingSortByValue(pixels, p => p[0] + p[1] + p[2]);
                    self.postMessage({ type: 'sortedFull', sortedPixels });
                }
            };
        `;
        
        let worker;

        function createWorker() {
            const blob = new Blob([workerScript], { type: 'application/javascript' });
            worker = new Worker(URL.createObjectURL(blob));
            worker.onmessage = async (e) => {
                if (isCancelled) return;
                const { type, sortedPixels } = e.data;
                if (type === 'sortedFull') {
                    setLoading(true, "Animating result...");
                    await animateFullFrame(sortedPixels);
                    if (!isCancelled) finalizeSort();
                }
            };
        }

        // --- Effects Definition ---
        const effects = {
            rgb: { name: 'RGB Sort', type: 'worker', options: {} },
            wind: { name: 'Wind', type: 'main', options: {} },
            jagged: { name: 'Jagged', type: 'main', options: {} },
            sliceSort: { name: 'Slice Sort', type: 'main', options: { sliceCount: { label: 'Slices', min: 4, max: 64, value: 16 } } },
            scanline: { name: 'Scanline', type: 'main', options: { segmentPct: { label: 'Segment %', min: 10, max: 90, value: 50 } } },
            pixelate: { name: 'Pixelate', type: 'main', realtime: true, options: { pixelSize: { label: 'Pixel Size', min: 2, max: 64, value: 16 } } },
            matrix: { name: 'Matrix', type: 'main', options: { speed: { label: 'Speed', min: 10, max: 100, value: 30 } } },
            dnaGel: { name: 'DNA Gel', type: 'main', options: { offset: { label: 'Offset', min: 1, max: 40, value: 20 } } },
            crystallize: { name: 'Crystallize', type: 'main', options: { points: { label: 'Crystals', min: 10, max: 49, value: 40 } } },
            inception: { name: 'Bending', type: 'main', realtime: true, options: { amplitude: { label: 'Amplitude', min: 0, max: 100, value: 20 }, frequency: { label: 'Frequency', min: 1, max: 100, value: 10 } } },
            predator: { name: 'Thermal', type: 'main', options: {} },
            bladeRunner: { name: 'Glare', type: 'main', options: { threshold: { label: 'Brightness', min: 200, max: 255, value: 240 }, strength: { label: 'Strength', min: 1, max: 10, value: 5 } } },
            stargate: { name: 'Stargate', type: 'main', options: { strength: { label: 'Strength', min: 1, max: 100, value: 50 } } },
            static: { name: 'Static', type: 'main', options: { amount: { label: 'Amount', min: 0, max: 100, value: 20 } } },
            sinCity: { name: 'Selective Color', type: 'main', options: { hue: { label: 'Hue', min: 0, max: 360, value: 0 }, tolerance: { label: 'Tolerance', min: 0, max: 100, value: 20 } } },
            pleasantville: { name: 'Color Bleed', type: 'main', options: { speed: { label: 'Speed', min: 1, max: 20, value: 5 } } },
            tron: { name: 'Grid Lines', type: 'main', options: { spacing: { label: 'Spacing', min: 10, max: 100, value: 40 }, lineWidth: { label: 'Width', min: 1, max: 10, value: 2 } } },
            underwater: { name: 'Underwater', type: 'main', realtime: true, options: { amplitude: { label: 'Amplitude', min: 0, max: 50, value: 10 }, frequency: { label: 'Frequency', min: 1, max: 50, value: 5 } } },
            sepia: { name: 'Sepia Tone', type: 'main', options: {} }
        };

        // --- UI & Controls ---
        function populateEffectsGrid() {
            effectsGrid.innerHTML = '';
            for (const id in effects) {
                const button = document.createElement('button');
                button.id = `${id}EffectBtn`;
                button.className = 'effect-btn bg-gray-600 p-3 rounded-lg text-center font-medium hover:bg-purple-600 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-purple-500 disabled:opacity-50 disabled:cursor-not-allowed';
                button.textContent = effects[id].name;
                button.disabled = true;
                button.addEventListener('click', () => selectEffect(id));
                effectsGrid.appendChild(button);
            }
            const randomizeBtn = document.createElement('button');
            randomizeBtn.id = 'randomizeBtn';
            randomizeBtn.className = 'w-full bg-pink-600 md:col-span-3 p-3 rounded-lg text-center font-medium hover:bg-pink-700 transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-pink-500 disabled:opacity-50 disabled:cursor-not-allowed';
            randomizeBtn.textContent = 'Randomize!';
            randomizeBtn.disabled = true;
            randomizeBtn.onclick = randomizeEffect;
            effectsGrid.appendChild(randomizeBtn);
            allButtons = Array.from(document.querySelectorAll('.effect-btn, #randomizeBtn'));
        }

        function selectEffect(id) {
            activeEffect = id;
            document.querySelectorAll('.effect-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`${id}EffectBtn`).classList.add('active');
            populateOptions(id);

            const effect = effects[id];
            if (effect.realtime) {
                runActiveEffect();
            } else if (!Object.keys(effect.options).length) {
                runActiveEffect();
            }
        }

        function populateOptions(id) {
            optionsContainer.innerHTML = '';
            const effect = effects[id];
            if (!Object.keys(effect.options).length) return;

            const title = document.createElement('h3');
            title.className = 'text-lg font-medium text-gray-300';
            title.textContent = `${effect.name} Options`;
            optionsContainer.appendChild(title);

            for (const optId in effect.options) {
                const opt = effect.options[optId];
                const wrapper = document.createElement('div');
                const label = document.createElement('label');
                label.className = 'block text-sm font-medium text-gray-400';
                label.textContent = `${opt.label}: `;
                const valueSpan = document.createElement('span');
                valueSpan.id = `${id}-${optId}-label`;
                valueSpan.textContent = opt.value;
                label.appendChild(valueSpan);

                const slider = document.createElement('input');
                slider.type = 'range';
                slider.id = `${id}-${optId}-slider`;
                slider.min = opt.min;
                slider.max = opt.max;
                slider.value = opt.value;
                slider.className = 'w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer';
                
                const eventType = effect.realtime ? 'input' : 'change';
                slider.addEventListener(eventType, (e) => {
                    valueSpan.textContent = e.target.value;
                    if (effect.realtime) {
                        clearTimeout(debounceTimer);
                        debounceTimer = setTimeout(() => runActiveEffect(), 50);
                    }
                });
                
                wrapper.appendChild(label);
                wrapper.appendChild(slider);
                optionsContainer.appendChild(wrapper);
            }
            
            if (!effect.realtime) {
                const applyBtn = document.createElement('button');
                applyBtn.textContent = 'Apply Effect';
                applyBtn.className = 'w-full bg-indigo-600 p-3 rounded-lg text-center font-medium hover:bg-indigo-700';
                applyBtn.onclick = runActiveEffect;
                optionsContainer.appendChild(applyBtn);
            }
        }

        function getEffectOptions(id) {
            const options = {};
            if (!effects[id]) return options;
            for (const optId in effects[id].options) {
                const slider = document.getElementById(`${id}-${optId}-slider`);
                if (slider) options[optId] = parseFloat(slider.value);
            }
            return options;
        }

        async function runActiveEffect() {
            if (!activeEffect) return;
            const effect = effects[activeEffect];
            const options = getEffectOptions(activeEffect);

            if (effect.type === 'worker') {
                startWorkerEffect(activeEffect, options);
            } else {
                const logic = effectLogics[activeEffect];
                if(logic) await mainThreadEffect(effect.name, () => logic(options));
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            createWorker();
            populateEffectsGrid();
        });

        // --- Image Loading ---
        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                originalImage.onload = () => {
                    canvas.width = originalImage.width; canvas.height = originalImage.height;
                    ctx.drawImage(originalImage, 0, 0);
                    originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    allButtons.forEach(btn => btn.disabled = false);
                    resetBtn.disabled = false;
                    downloadBtn.classList.add('hidden');
                    canvas.classList.remove('hidden'); canvasPlaceholder.classList.add('hidden');
                };
                originalImage.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });
        
        // --- Event Listeners ---
        cancelBtn.addEventListener('click', () => {
            isCancelled = true; worker.terminate(); createWorker(); setLoading(false);
            if(originalImageData) ctx.putImageData(originalImageData, 0, 0);
        });
        
        resetBtn.addEventListener('click', () => { if (originalImageData) { ctx.putImageData(originalImageData, 0, 0); downloadBtn.classList.add('hidden'); } });

        // --- Functions to start effects ---
        function startWorkerEffect(mode, options) {
            if (!originalImageData) return;
            ctx.putImageData(originalImageData, 0, 0);
            setLoading(true, "Processing in background...");
            worker.postMessage({ type: 'sortFull', imageData: originalImageData, sortType: mode, options });
        }

        async function mainThreadEffect(effectName, effectLogic) {
            if (!originalImageData) return;
            if(!effects[activeEffect] || !effects[activeEffect].realtime) {
                ctx.putImageData(originalImageData, 0, 0);
            }
            setLoading(true, `Creating ${effectName} effect...`);
            await sleep(50);
            await effectLogic();
            if (!isCancelled) finalizeSort();
        }

        // --- Main Thread Effect Logic ---
        const effectLogics = {
            wind: async () => { const batchSize = 20; for (let y = 0; y < canvas.height; y += batchSize) { if(isCancelled) break; for(let i=0; i<batchSize && (y+i)<canvas.height; i++){ const currentY = y+i; const r=ctx.getImageData(0,currentY,canvas.width,1); const p=getPixelArray(r.data); const s=countingSortByValue(p,p=>p[0]+p[1]+p[2]); ctx.putImageData(flattenPixelArray(s,r),0,currentY); } await sleep(0); } },
            jagged: async () => { const batchSize = 20; for (let y = 0; y < canvas.height; y += batchSize) { if(isCancelled) break; for(let i=0; i<batchSize && (y+i)<canvas.height; i++){ const currentY = y+i; const r=ctx.getImageData(0,currentY,canvas.width,1); const p=getPixelArray(r.data); let s=countingSortByValue(p,p=>p[0]+p[1]+p[2]); if(currentY % 2 !== 0)s.reverse(); ctx.putImageData(flattenPixelArray(s,r),0,currentY); } await sleep(0); } },
            scanline: async (opts) => { const {width,height}=canvas; for (let y=0;y<height;y++) { if(isCancelled)break; const segW=(width*(opts.segmentPct/100)); const sX=Math.random()*(width-segW); const r=ctx.getImageData(sX,y,segW,1); const p=getPixelArray(r.data); const s=countingSortByValue(p,p=>p[0]+p[1]+p[2]); ctx.putImageData(flattenPixelArray(s,r),sX,y); if(y%4===0)await sleep(0); } },
            sliceSort: async (opts) => { const {width,height}=canvas; const sC=opts.sliceCount; const sW=Math.floor(width/sC); const tC=document.createElement('canvas'); tC.width=width;tC.height=height; const tX=tC.getContext('2d'); let sP=Array.from({length:sC},(_,i)=>i*sW); for(let i=sP.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[sP[i],sP[j]]=[sP[j],sP[i]];} for(let i=0;i<sC;i++){ if(isCancelled)return; const sID=ctx.getImageData(i*sW,0,sW,height); const p=getPixelArray(sID.data); const sPxs=countingSortByValue(p,p=>p[0]+p[1]+p[2]); tX.putImageData(flattenPixelArray(sPxs,sID),sP[i],0);} ctx.drawImage(tC,0,0); },
            pixelate: async (opts) => { const {width,height}=canvas; const pS=opts.pixelSize; for(let y=0;y<height;y+=pS){ for(let x=0;x<width;x+=pS){ const blockData=ctx.getImageData(x,y,pS,pS).data; let r=0,g=0,b=0,c=0; for(let i=0;i<blockData.length;i+=4){r+=blockData[i];g+=blockData[i+1];b+=blockData[i+2];c++;} ctx.fillStyle=`rgb(${r/c},${g/c},${b/c})`; ctx.fillRect(x,y,pS,pS); } } },
            matrix: async (opts) => { const {width,height}=canvas; const cS=Math.max(4,Math.floor(width/128)); const cols=Math.floor(width/cS); const drops=Array(cols).fill(1); const chars="日ﾊﾐﾋｰｳｼﾅﾓﾆｻﾜﾂｵﾘｱﾎﾃﾏｹﾒｴｶｷﾑﾕﾗｾﾈｽﾀﾇﾍ"; ctx.fillStyle="rgba(0,0,0,0.05)"; for(let i=0;i<200;i++){ if(isCancelled)return; for(let c=0;c<drops.length;c++){ const txt=chars[Math.floor(Math.random()*chars.length)]; const x=c*cS; const y=drops[c]*cS; ctx.fillStyle="#00FF41"; ctx.fillText(txt,x,y); if(Math.random()>0.975)ctx.fillStyle="#FFFFFF"; ctx.fillText(txt,x,y); drops[c]++; if(drops[c]*cS>height&&Math.random()>0.975)drops[c]=0; } ctx.fillStyle="rgba(0,0,0,0.05)"; ctx.fillRect(0,0,width,height); await sleep(opts.speed); } },
            dnaGel: async (opts) => { const {width,height}=canvas; const batchSize = 20; for(let y=0;y<height;y+=batchSize){ if(isCancelled)break; for(let i=0; i<batchSize && (y+i)<height; i++){ const currentY = y+i; const r=ctx.getImageData(0,currentY,width,1); const p=getPixelArray(r.data); const s=p.sort((a,b)=>(a[0]+a[1]+a[2])-(b[0]+b[1]+b[2])); const nR=ctx.createImageData(width,1); for(let j=0;j<s.length;j++){ const px=s[j]; const br=(px[0]+px[1]+px[2])/765; const offset=Math.floor(Math.pow(br,2)*width*(opts.offset/100)); nR.data[(j*4)]=px[0];nR.data[(j*4)+1]=px[1];nR.data[(j*4)+2]=px[2];nR.data[(j*4)+3]=px[3]; } ctx.putImageData(nR,0,currentY); } await sleep(0); } },
            crystallize: async (opts) => { const {width,height}=canvas; const tC=document.createElement('canvas'); tC.width=width;tC.height=height; const tX=tC.getContext('2d'); const nP=opts.points; const pts=[]; for(let i=0;i<nP;i++){pts.push({x:Math.random()*width,y:Math.random()*height,r:0,g:0,b:0,count:0});} const data=originalImageData.data; const batchSize = 50; for(let y=0;y<height;y++){ if(isCancelled) return; for(let x=0;x<width;x++){ let cl=0,mD=Infinity; for(let i=0;i<pts.length;i++){ const d=Math.sqrt(Math.pow(x-pts[i].x,2)+Math.pow(y-pts[i].y,2)); if(d<mD){mD=d;cl=i;} } const idx=(y*width+x)*4; pts[cl].r+=data[idx];pts[cl].g+=data[idx+1];pts[cl].b+=data[idx+2];pts[cl].count++;} if (y % batchSize === 0) await sleep(0); } if(isCancelled) return; for(let y=0;y<height;y++){ if(isCancelled)return; for(let x=0;x<width;x++){ let cl=0,mD=Infinity; for(let i=0;i<pts.length;i++){ const d=Math.sqrt(Math.pow(x-pts[i].x,2)+Math.pow(y-pts[i].y,2)); if(d<mD){mD=d;cl=i;} } const p=pts[cl]; tX.fillStyle=`rgb(${p.r/p.count},${p.g/p.count},${p.b/p.count})`; tX.fillRect(x,y,1,1); } } ctx.drawImage(tC,0,0); },
            inception: async (opts) => { const {width,height}=canvas; const tC=document.createElement('canvas'); tC.width=width;tC.height=height; const tX=tC.getContext('2d'); for(let y=0;y<height;y++){ if(isCancelled)return; const xOffset=Math.sin(y/(height/opts.frequency))*opts.amplitude; tX.drawImage(canvas,0,y,width,1,xOffset,y,width,1); } ctx.clearRect(0,0,width,height); ctx.drawImage(tC,0,0); },
            predator: async () => { const data=ctx.getImageData(0,0,canvas.width,canvas.height); const d=data.data; for(let i=0;i<d.length;i+=4){ const brightness=(d[i]+d[i+1]+d[i+2])/3; const p=brightness/255; let r=0,g=0,b=0; if(p<0.25){r=0;g=0;b=255*(4*p);}else if(p<0.5){r=0;g=255*(4*(p-0.25));b=255;}else if(p<0.75){r=255*(4*(p-0.5));g=255;b=255-(255*(4*(p-0.5)));}else{r=255;g=255-(255*(4*(p-0.75)));b=0;} d[i]=r;d[i+1]=g;d[i+2]=b;} ctx.putImageData(data,0,0); },
            bladeRunner: async(opts)=>{ const {width,height}=canvas; const data=ctx.getImageData(0,0,width,height).data; ctx.drawImage(originalImage,0,0); ctx.fillStyle=`rgba(255,200,150,${opts.strength/20})`; for(let y=0;y<height;y++){for(let x=0;x<width;x++){const i=(y*width+x)*4; const brightness=(data[i]+data[i+1]+data[i+2])/3; if(brightness>opts.threshold){ctx.fillRect(0,y,width,1);}}} },
            stargate: async (opts) => { const {width,height}=canvas; const cX=width/2,cY=height/2; const tC=document.createElement('canvas'); tC.width=width;tC.height=height; const tX=tC.getContext('2d'); tX.drawImage(canvas,0,0); for(let i=0;i<360;i+=4){ if(isCancelled)return; tX.save(); tX.translate(cX,cY); tX.rotate(i*Math.PI/180); tX.scale(1+opts.strength/100,1); tX.drawImage(canvas, -cX, -cY); tX.restore(); } ctx.drawImage(tC,0,0); },
            static: async (opts) => { const data=ctx.getImageData(0,0,canvas.width,canvas.height); const d=data.data; for(let i=0;i<d.length;i+=4){if(Math.random()<(opts.amount/100)){const v=Math.random()*255;d[i]=v;d[i+1]=v;d[i+2]=v;}} ctx.putImageData(data,0,0); },
            sinCity: async (opts) => { const data=ctx.getImageData(0,0,canvas.width,canvas.height); const d=data.data; const targetHue=opts.hue/360; const tolerance=opts.tolerance/360; for(let i=0;i<d.length;i+=4){ const [h,s,l]=rgbToHsl(d[i],d[i+1],d[i+2]); const dist=Math.abs(h-targetHue); if(dist>tolerance&&dist<1-tolerance){ const gray=d[i]*0.299+d[i+1]*0.587+d[i+2]*0.114; d[i]=gray;d[i+1]=gray;d[i+2]=gray;}} ctx.putImageData(data,0,0); },
            pleasantville: async (opts) => { const {width,height}=canvas; const grayCanvas=document.createElement('canvas'); grayCanvas.width=width;grayCanvas.height=height; const grayCtx=grayCanvas.getContext('2d'); grayCtx.drawImage(originalImage,0,0); const data=grayCtx.getImageData(0,0,width,height); const d=data.data; for(let i=0;i<d.length;i+=4){const gray=d[i]*0.299+d[i+1]*0.587+d[i+2]*0.114; d[i]=gray;d[i+1]=gray;d[i+2]=gray;} grayCtx.putImageData(data,0,0); const maxRadius=Math.sqrt(width*width+height*height); for(let r=0;r<maxRadius;r+=opts.speed){ if(isCancelled)return; ctx.drawImage(grayCanvas,0,0); ctx.save(); ctx.beginPath(); ctx.arc(width/2,height/2,r,0,Math.PI*2); ctx.clip(); ctx.drawImage(originalImage,0,0); ctx.restore(); await sleep(10); } },
            tron: async (opts) => { ctx.drawImage(originalImage,0,0); ctx.strokeStyle='rgba(137,247,254,0.7)'; ctx.lineWidth=opts.lineWidth; for(let x=0;x<canvas.width;x+=opts.spacing){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,canvas.height);ctx.stroke();} for(let y=0;y<canvas.height;y+=opts.spacing){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(canvas.width,y);ctx.stroke();} },
            underwater: async (opts) => { const {width,height}=canvas; const tC=document.createElement('canvas'); tC.width=width;tC.height=height; const tX=tC.getContext('2d'); for(let y=0;y<height;y++){ const xOffset=Math.sin(y/(height/(opts.frequency*Math.PI)))*opts.amplitude; tX.drawImage(canvas,0,y,width,1,xOffset,y,width,1); } ctx.clearRect(0,0,width,height); ctx.drawImage(tC,0,0); ctx.fillStyle='rgba(0,100,200,0.2)'; ctx.fillRect(0,0,width,height); },
            sepia: async () => { const data=ctx.getImageData(0,0,canvas.width,canvas.height); const d=data.data; for(let i=0;i<d.length;i+=4){const r=d[i],g=d[i+1],b=d[i+2]; d[i]=Math.min(255,r*0.393+g*0.769+b*0.189); d[i+1]=Math.min(255,r*0.349+g*0.686+b*0.168); d[i+2]=Math.min(255,r*0.272+g*0.534+b*0.131);} ctx.putImageData(data,0,0); }
        };

        async function randomizeEffect() { const effectKeys = Object.keys(effects); const randomEffectId = effectKeys[Math.floor(Math.random() * effectKeys.length)]; selectEffect(randomEffectId); await sleep(100); const effect = effects[randomEffectId]; if(Object.keys(effect.options).length > 0) { for(const optId in effect.options) { const opt = effect.options[optId]; const slider = document.getElementById(`${randomEffectId}-${optId}-slider`); const randVal = Math.floor(Math.random() * (opt.max - opt.min + 1)) + opt.min; slider.value = randVal; document.getElementById(`${randomEffectId}-${optId}-label`).textContent = randVal; } } runActiveEffect(); }

        async function animateFullFrame(sortedPixels) { const {width,height}=canvas; const nID=ctx.createImageData(width,height); let sPI=0; for(let y=0;y<height;y++){ if(isCancelled)return; for(let x=0;x<width;x++){ if(sPI<sortedPixels.length){ const p=sortedPixels[sPI++]; const dI=(y*width+x)*4; nID.data[dI]=p[0];nID.data[dI+1]=p[1];nID.data[dI+2]=p[2];nID.data[dI+3]=p[3]; } } ctx.putImageData(nID,0,0); await sleep(0); } }
        async function animateSpiral(sortedPixels, spiralCoords) { if(isCancelled)return; const {width,height}=canvas; const nID=ctx.createImageData(width,height); for(let i=0;i<spiralCoords.length;i++){ const {x,y}=spiralCoords[i]; if(i<sortedPixels.length){ const p=sortedPixels[i]; const dI=(y*width+x)*4; nID.data[dI]=p[0];nID.data[dI+1]=p[1];nID.data[dI+2]=p[2];nID.data[dI+3]=p[3]; } } ctx.putImageData(nID,0,0); }

        function finalizeSort() { downloadBtn.href=canvas.toDataURL('image/png'); downloadBtn.classList.remove('hidden'); setLoading(false); }
        function setLoading(isLoading, text="Processing...") { if(isLoading)isCancelled=false; loader.classList.toggle('hidden',!isLoading); loaderText.textContent=text; allButtons.forEach(btn=>btn.disabled=isLoading); resetBtn.disabled=isLoading; }
        
        function getPixelArray(data){const p=[];for(let i=0;i<data.length;i+=4)p.push([data[i],data[i+1],data[i+2],data[i+3]]);return p;}
        function flattenPixelArray(pixels,imageData){const d=imageData.data;for(let i=0;i<pixels.length;i++){const p=pixels[i];d[i*4]=p[0];d[i*4+1]=p[1];d[i*4+2]=p[2];d[i*4+3]=p[3];}return imageData;}
        function countingSortByValue(pixels,getValue){const buckets={};for(const p of pixels){const v=getValue(p);if(!buckets[v])buckets[v]=[];buckets[v].push(p);}const sP=[];const sK=Object.keys(buckets).map(Number).sort((a,b)=>a-b);for(const k of sK){const bucket=buckets[k];for(let i=0;i<bucket.length;i++)sP.push(bucket[i]);}return sP;}
        function rgbToHsl(r,g,b){r/=255,g/=255,b/=255;let max=Math.max(r,g,b),min=Math.min(r,g,b);let h,s,l=(max+min)/2;if(max==min){h=s=0;}else{let d=max-min;s=l>0.5?d/(2-max-min):d/(max+min);switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h/=6;}return [h,s,l];}
    </script>
</body>
</html>
